import sys
sys.stdin = open('input.txt')

# 상하좌우
dx
dy

def f(r, acc_score, acc_line):
    '''1. 조사 규칙 정리
        모든 후보군에 대해서 조사를 한다.
            이때... 코어의 순서 중요한가?
        모든 후보군에 대해서 다 조사를 출발시켰는가?
            - 아 그럼, 종료조건은 내가 지금 몇 번째 후보군을 조사하고 있는지
            이번 후보군을 가지고 전선이었던 것들 지울 수도 있어야 할 듯?
                원복시킬 방법 생각해야할 듯? -> 백트래킹 방식으로
                    재귀형식인가? N이 작고, 조건이 간단해서 limit 안 걸릴 듯?
            그 조사방식... 내가 점점 앞으로 나아가는 방식? 재귀 필요한가?
                아니? 직선으로 범위 벗어날 때까지, 혹은 더 못 갈 때까지만 하면 되는데
                그냥 while하면 될 듯?
                그걸 상하좌우 4번 해야할 듯?
        그 후보군을 선택 안 한다고 생각해봐야 함.
    '''
    '''99. 가지치기
        유망성 없는 경우는 무엇인가?
        1. 최대한 많은 코어를 구할 것이다.
            -> 이때 유망성 없는 상황은 뭘까?
            지금까지 선택한 코어 + 아직 선택 안 했지만 선택할 수도 있는 코어
            의 수가
            이미 예전에 구했던 최대 코어보다 작으면?
        2. 코어가 최대한 많아야 하고, 전선으니 최대한 짧아야 한다...?
            전선이 짧아야 하니까... 누적된 코어가 최대 코어랑 같은데
            전선이 이미 더 길어...
            유망성 있나?
            섣부른 가지치기가 될 수도 있다.
            왜?
            사실 이 문제의 가장 큰 문제는 더 많은 코어
            -----> 가지치기 못함 (코어를 많이 추가하면 전선의 길이가 길어져도 상관 X)
    '''
    if 지금까지 선택한 코어 + 아직 선택 안 했지만 선택할 수도 있는 코어 < 최대 코어:
        유망성 없음

    if 현재 조사 중인 후보군 idx == R (모든 후보군의 개수만큼)
        '''99. 값 갱신
            누적 코어 개수, 현재 찾은 최대 코어 개수 비교
            누적 코어 == 최대 코어
                전선이 더 짧을 때 전선만 갱신
            누적 코어 > 최대 코어
                최대 코어 개수 갱신
                전선도 갱신
        '''
    # 전수조사
    '''2. 이번 후보군에 대한 조사 방식
        이번 후보군이 누군데? 재귀형식으로 할 거였으니까? 인자 추가
        이번 회차에서 전선 연결 가능한지 찾았으면
            그 전선 개수, 이번 후보군 코어 선택했으니까, 누적 인자 추가
    
    '''
    x, y -> candidate[r]
    for k > 4:
        nx + k
        ny + k
        temp_line >> []
        # 갈 수 있을 때까지 간다
        while 0 <= nx, ny <= N and data x, y == 0:
            temp_line + (nx, ny)
            # 전선을 이어 나갈까? 원본을 바꿀까?
            # 원본을 지금 쭉 바꿔나가면 나중에... 백트래킹해서 돌아왔을 때
            # 어디서부터 어디까지 다시 0으로 돌려야할까?
            # 전선을 어느 좌표에 전선처리 했는지 모아두면 안 됨?
            nx + k, ny + k >> 한 방향으로 계속 이동
        # 위에서 한 방향으로 쭉 갔는데...
        if 0 <= nx, ny < N:     >> 여전히 셀 안이다? 가장자리 도달 못했나보네?
            continue            >> 이 방향으로는 전선을 연결할 수 없나보네.

        # 끝까지 갔어? 그럼 모았던 전선들 모두 원본에 전선처리해서
        # 다음 조사에 영향 미치도록 해두기
        for line pos > temp_line:
            data line pos -> -1

        # 다음 후보군 선택하러 가기
        f(r++, acc_score++, acc_line+len(temp_line))

        # 조사 갔다가 돌아왔다? 다음 선택지에 영향 안 미치도록 원복
        for line pos > temp_line:
            data
            line
            pos -> 0
    # 이번 후보군 아예 선택 안 하기
    f(r++ ... )

'''0. 규칙 정리
    첫 번째. 셀 범위 밖으로 직선으로 이어야 한다.
        최대한 많은 코어가 (모든 코어가 가능한지 조사)
    두 번째. 가장자리에 있는 코어는 이미 연결되어 있다. (나의 탐색 조사 대상이다.)
        이미 연결되어 있으니, 조사 대상은 아니지만
        결과에는 영향을 미친다. 즉, 시작할 때 코어가 이미 가장자리 개수만큼 초기화
    세 번째. 전선은 교차가 안 된다.
    네 번째. 최대한 많은 코어, 최대한 짧은 전선
        최대한 짧은 전선? 나랑 가장 가까운 벽 찾기?
        직접 보내야 한다. (완전탐색해야 한다.)
'''


T
for tc -> 1, T
    N
    data -> N*N >> 0벽, 1코어
    # 최종 출력 대상 초기화
    # 가장 바보같은 선택지를 생각해보자.
    r -> 전선의 길이 최대한 짧아야 한다.: N*N
    c -> 코어의 개수: 0
    '''1. 조사를 위한 준비
        조사 대상 (후보군): 코어
        단, 가장자리가 아닌 코어들
            반대로, 가장자리의 코어는? 초기값에 넣어두자.    
    '''
    candidate >> []
    for x > N
        for y > N
            data x, y:  < 코어가 있음
                r-- < 전선 연결 못함
                if 가장자리인 경우
                    c++     <- 이미 확정된 코어임
                    data x, y <- -1로 변경 (조사 대상 아니고, 전선 연결도 못함)
            코어가 있고, 가장자리도 아니면 후보군에 추가
    이제 내가 가진 모든 후보군에 대한 조사
    몇 개? len(후보군)
    # 일단 전수조사
    f(0, c, 0) <- 함수에 인자 뭐 넣어야 하는지 모르겠네